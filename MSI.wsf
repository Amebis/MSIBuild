<?xml version="1.0"?>
<package>
	<job id="MakeDDF">
		<runtime>
			<description>Compile DDF file for shared CAB archive from input MSI files.</description>
			<unnamed name="&lt;output.ddf&gt;" helpstring="Output DDF file" required="true"/>
			<unnamed name="&lt;input.msi ...&gt;" helpstring="Input MSI files" required="true"/>
			<named name="I" helpstring="Input files folder" type="string" required="false"/>
			<named name="O" helpstring="CAB archive base name (default &quot;Dat&quot;)" type="string" required="false"/>
			<named name="C" helpstring="Compression (default &quot;MSZIP&quot;)" type="string" required="false"/>
		</runtime>
		<script language="JScript" src="MSI.js"/>
		<script language="JScript"><![CDATA[
			if (WScript.Arguments.Unnamed.Length < 2) {
				WScript.Arguments.ShowUsage();
				WScript.Quit(1);
			}

			try {
				var
					installer   = WScript.CreateObject("WindowsInstaller.Installer"),
					fso         = WScript.CreateObject("Scripting.FileSystemObject"),
					input_path  = WScript.Arguments.Named.Exists("I") ? WScript.Arguments.Named("I") : null,
					output_base = WScript.Arguments.Named.Exists("O") ? WScript.Arguments.Named("O") : "Dat",
					compression = WScript.Arguments.Named.Exists("C") ? WScript.Arguments.Named("C") : "MSZIP",
					ddf_path    = WScript.Arguments.Unnamed(0),
					files       = new Array(),
					i, n = WScript.Arguments.Unnamed.length;

				// No user interaction is desired.
				installer.UILevel = msiUILevelNone;

				for (i = 1; i < n; i++) {
					var
						msi_path = WScript.Arguments.Unnamed(i),
						d;

					d = MSIGetFiles(installer, msi_path, input_path);
					MSIMergeFiles(files, d);

					// Force JScript engine to free database and session objects, otherwise opening of another session will fail.
					CollectGarbage();
				}

				// Create DDF file and write header properties.
				var
					dat = fso.CreateTextFile(ddf_path, true, false);

				try {
					dat.WriteLine(".Set CabinetNameTemplate=" + output_base + "*.cab");
					dat.WriteLine(".Set CabinetName1=" + output_base + ".cab");
					dat.WriteLine(".Set InfFileName=" + output_base + ".inf");
					dat.WriteLine(".Set RptFileName=" + output_base + ".rpt");
					dat.WriteLine(".Set ReservePerCabinetSize=8");
					dat.WriteLine(".Set MaxDiskSize=0");
					dat.WriteLine(".Set CompressionType=" + compression);
					dat.WriteLine(".Set InfFileLineFormat=(*disk#*) *file#*: *file* = *Size*");
					dat.WriteLine(".Set InfHeader=");
					dat.WriteLine(".Set InfFooter=");
					dat.WriteLine(".Set InfDateFormat=yyyy-mm-dd");
					dat.WriteLine(".Set DiskDirectoryTemplate=");
					dat.WriteLine(".Set Compress=ON");
					dat.WriteLine(".Set Cabinet=ON");
					//if (input_path)
					//	dat.WriteLine(".Set SourceDir=" + input_path);
					for (fileKey in files) {
						var
							f = fso.GetFile(files[fileKey]),
							d = new Date(f.DateLastModified);

						// Seconds should be even. This is MAKECAB limitation.
						d.setSeconds(Math.round(d.getSeconds() / 2) * 2);

						dat.WriteLine("\"" + files[fileKey] + "\" /Date=" + d.getFullYear() + "-" + (d.getMonth() + 1) + "-" + d.getDate() + " /Time=" + Time2Str(d) + " " + fileKey);
					}
				} finally {
					dat.Close();
				}
			} catch (err) {
				// In case of error, delete output file.
				if (fso.FileExists(ddf_path))
					fso.DeleteFile(ddf_path);

				throw err;
			}

			WScript.Quit(0);
		]]></script>
	</job>
	<job id="MakeDEP">
		<runtime>
			<description>Compile DEP dependency file from input MSI files.</description>
			<unnamed name="&lt;output.dep&gt;" helpstring="Output DEP file" required="true"/>
			<unnamed name="&lt;target file&gt;" helpstring="Target file dependant of input" required="true"/>
			<unnamed name="&lt;input.msi ...&gt;" helpstring="Input MSI files" required="true"/>
			<named name="I" helpstring="Input files folder" type="string" required="false"/>
		</runtime>
		<script language="JScript" src="MSI.js"/>
		<script language="JScript"><![CDATA[
			if (WScript.Arguments.Unnamed.Length < 3) {
				WScript.Arguments.ShowUsage();
				WScript.Quit(1);
			}

			try {
				var
					installer   = WScript.CreateObject("WindowsInstaller.Installer"),
					fso         = WScript.CreateObject("Scripting.FileSystemObject"),
					input_path  = WScript.Arguments.Named.Exists("I") ? WScript.Arguments.Named("I") : null,
					dep_path    = WScript.Arguments.Unnamed(0),
					target_path = WScript.Arguments.Unnamed(1),
					files       = new Array(),
					i, n = WScript.Arguments.Unnamed.length;

				// No user interaction is desired.
				installer.UILevel = msiUILevelNone;

				for (i = 2; i < n; i++) {
					var
						msi_path = WScript.Arguments.Unnamed(i),
						d;

					d = MSIGetFiles(installer, msi_path, input_path);
					MSIMergeFiles(files, d);

					// Force JScript engine to free database and session objects, otherwise opening of another session will fail.
					CollectGarbage();
				}

				var
					dat = fso.CreateTextFile(dep_path, true, false);

				try {
					dat.Write("\"" + target_path + "\" :");
					for (fileKey in files)
						dat.Write(" \\\r\n\t\"" + files[fileKey] + "\"");
					dat.WriteLine();
					dat.WriteLine();
				} finally {
					dat.Close();
				}
			} catch (err) {
				// In case of error, delete output file.
				if (fso.FileExists(dep_path))
					fso.DeleteFile(dep_path);

				throw err;
			}

			WScript.Quit(0);
		]]></script>
	</job>
	<job id="SetCAB">
		<runtime>
			<description>Configures MSI package to use external CAB file.</description>
			<unnamed name="&lt;output.msi&gt;" helpstring="Output MSI file" required="true"/>
			<unnamed name="&lt;input.inf&gt;" helpstring="Input INF file" required="true"/>
			<named name="I" helpstring="Input files folder" type="string" required="false"/>
			<named name="E" helpstring="Embed CAB file" type="simple" required="false"/>
		</runtime>
		<script language="JScript" src="MSI.js"/>
		<script language="JScript"><![CDATA[
			if (WScript.Arguments.Unnamed.Length < 2) {
				WScript.Arguments.ShowUsage();
				WScript.Quit(1);
			}

			var
				installer  = WScript.CreateObject("WindowsInstaller.Installer"),
				fso        = WScript.CreateObject("Scripting.FileSystemObject"),
				input_path = WScript.Arguments.Named.Exists("I") ? WScript.Arguments.Named("I") : "",
				embed      = WScript.Arguments.Named.Exists("E") ? true : false,
				msi_path   = WScript.Arguments.Unnamed(0),
				inf_path   = WScript.Arguments.Unnamed(1),
				cab_path   = null,
				cab_name;

			// No user interaction is desired.
			installer.UILevel = msiUILevelNone;

			var
				database     = installer.OpenDatabase(msi_path, msiOpenDatabaseModeTransact),
				session      = installer.OpenPackage(database, 1),
				shortNames   = session.Mode(msiRunModeSourceShortNames),
				lastSequence = 0,
				stat,
				view,
				record,
				updateMode,
				sumInfo,
				today = new Date();

			if (input_path)
				session.Property("OriginalDatabase") = input_path;

			stat = session.DoAction("CostInitialize");
			if (stat != 1)
				throw new Error("Error calling CostInitialize() (code " + stat + ").");

			var
				dat = fso.OpenTextFile(inf_path, 1);

			try {
				var
					section         = null,
					re_section      = new RegExp("^\\s*\\[([^\\]]*)\\]\\s*$", "i"),
					re_file_list    = new RegExp("^\\s*\\((\\d+)\\)\\s*(\\d+)\\s*[:]([^=]+)[=]\\s*(\\d+)\\s*$", "i"),
					re_cabinet_list = new RegExp("^\\s*(\\d+)\\s*[,]\\s*(\\d+)\\s*[,](.*)$", "i");

				while (!dat.AtEndOfStream) {
					var
						s = new String(dat.ReadLine()),
						m;

					if (m = s.match(re_section)) {
						// We found a section.
						section = new String(m[1]);
					} else if (section.toLowerCase() == "file list") {
						if (m = s.match(re_file_list)) {
							var
								fileNum = parseInt(m[2], 10),
								fileId  = Trim(m[3]);

							// Set file sequence in database.
							view = database.OpenView("SELECT Sequence,Attributes FROM File WHERE File='" + _S(fileId) + "'");
							view.Execute();
							record = view.Fetch();
							if (record) {
								record.IntegerData(1) = fileNum;
								// record.IntegerData(2) = (record.IntegerData(2) & ~msidbFileAttributesNoncompressed) | msidbFileAttributesCompressed;
								view.Modify(msiViewModifyUpdate, record);
							}
							view.Close();

							if (fileNum > lastSequence)
								lastSequence = fileNum;
						}
					} else if (section.toLowerCase() == "cabinet list") {
						if (m = s.match(re_cabinet_list)) {
							if (cab_path)
								throw new Error("INF file can contain one CAB archive only.");

							// Read archive file name.
							cab_path = Trim(m[3]);
							cab_name = cab_path.split("\\");
							cab_name = cab_name[cab_name.length - 1];
						}
					}
				}
			} finally {
				dat.Close();
			}

			view = database.OpenView("SELECT DiskId,LastSequence,Cabinet FROM Media ORDER BY DiskId");
			view.Execute();
			record = view.Fetch();
			updateMode = msiViewModifyUpdate;
			if (!record) {
				// Media table is empty.
				record = installer.CreateRecord(3);
				record.IntegerData(1) = 1;
				updateMode = msiViewModifyInsert;
			}
			record.IntegerData(2) = lastSequence;
			record.StringData(3)  = (embed ? "#" : "") + cab_name;
			view.Modify(updateMode, record);

			sumInfo = database.SummaryInformation(3);
			sumInfo.Property(PID_LASTPRINTED)  = today.getVarDate();
			sumInfo.Property(PID_LASTSAVE_DTM) = today.getVarDate();
			sumInfo.Property(PID_WORDCOUNT)    = (shortNames ? 1 : 0) | 2;
			sumInfo.Persist();

			if (embed) {
				view = database.OpenView("SELECT Name,Data FROM _Streams");
				view.Execute();
				record = installer.CreateRecord(2);
				record.StringData(1) = cab_name;
				record.SetStream(2, cab_path);
				view.Modify(msiViewModifyAssign, record);
			}

			// Commit database
			database.Commit();

			WScript.Quit(0);
		]]></script>
	</job>
</package>
